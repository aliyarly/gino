# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-present, Fantix King
# This file is distributed under the same license as the GINO package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GINO 0.7.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-08-21 12:19+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Language-Team: Chinese (https://www.transifex.com/decentfox-studio/teams/84194/zh/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../schema.rst:3
msgid "Schema Declaration"
msgstr ""

#: ../../schema.rst:5
msgid ""
"There are 3 ways to declare your database schema to be used with GINO. "
"Because GINO is built on top of SQLAlchemy core, either way you are actually"
" declaring SQLAlchemy :class:`~sqlalchemy.schema.Table`."
msgstr "在使用GINO的过程中，存在三种方式来声明你所使用的数据库模式，
因为GINO是基于SQLAlchemy核心构建的，所以无论哪种方式，实际上都在声明SQLAlchemy Table。"

#: ../../schema.rst:11
msgid "GINO Engine"
msgstr "GINO 引擎"

#: ../../schema.rst:13
msgid ""
"This is the minimized way to use GINO - using only "
":class:`~gino.engine.GinoEngine` (and :class:`~gino.engine.GinoConnection` "
"too), everything else are vanilla SQLAlchemy core. This is useful when you "
"have legacy code written in SQLAlchemy core, in need of porting to asyncio. "
"For new code please use the other two."
msgstr "这是使用GINO最轻量的方式，仅仅使用":class:`~gino.engine.GinoEngine` 
(and :class:`~gino.engine.GinoConnection` "，其所包含的都是SQLAlchemy的核心功能，
这非常适合于存在使用SQLAlchemy开发的遗留代码，需要向异步转换的过程，如果是需要重新开发，
则推荐使用其它两种方式．
"

#: ../../schema.rst:19
msgid ""
"For example, the table declaration is the same as SQLAlchemy core `tutorial "
"<https://docs.sqlalchemy.org/en/latest/core/tutorial.html>`_::"
msgstr "例如，表的声明和SQLAlchemy是一样的"

#: ../../schema.rst:44
msgid ""
"When using GINO Engine only, it is usually your own business to create the "
"tables with either :meth:`~sqlalchemy.schema.MetaData.create_all` on a "
"normal non-async SQLAlchemy engine, or using Alembic. However it is still "
"possible to be done with GINO if it had to::"
msgstr "当只使用GINO引擎时，一般需要自行在普通的同步的SQLAlchemy引擎上，
通过`~sqlalchemy.schema.MetaData.create_all`创建表，　或者使用Alembic创建表，
如果非得采用GINO来创建的话，也是可以的．"

#: ../../schema.rst:56
msgid "Then, construct queries, in SQLAlchemy core too::"
msgstr "然后，以SQLAlchemy core的方式构建请求"

#: ../../schema.rst:60
msgid ""
"So far, everything is still in SQLAlchemy. Now let's get connected and "
"execute the insert::"
msgstr "目前为止，都是采用的SQLAlchemy的方式，现在连接数据库并执行插入语句"

#: ../../schema.rst:70
msgid ""
"Here :func:`~gino.create_engine` creates a :class:`~gino.engine.GinoEngine`,"
" then :meth:`~gino.engine.GinoEngine.acquire` checks out a "
":class:`~gino.engine.GinoConnection`, and "
":meth:`~gino.engine.GinoConnection.status` executes the insert and returns "
"the status text. This works similarly as SQLAlchemy "
":meth:`~sqlalchemy.engine.Connection.execute` - they take the same "
"parameters but return a bit differently. There are also other similar query "
"APIs:"
msgstr "函数`~gino.create_engine`创建了`~gino.engine.GinoEngine`类，`~gino.engine.GinoEngine.acquire`
获取了一个`~gino.engine.GinoConnection`连接对象，`~gino.engine.GinoConnection.status`执行了插入并返回执行的状态，
这些操作和SQLAlchemy的`~sqlalchemy.engine.Connection.execute`的作用时一样的大，获取一样的参数，唯一区别时返回的值有些不同，
也存在其它一些相似的APis"

#: ../../schema.rst:78
msgid ""
":meth:`~gino.engine.GinoConnection.all` returns a list of "
":class:`~sqlalchemy.engine.RowProxy`"
msgstr "`~gino.engine.GinoConnection.all`返回`~sqlalchemy.engine.RowProxy`列表对象"

#: ../../schema.rst:80
msgid ""
":meth:`~gino.engine.GinoConnection.first` returns one "
":class:`~sqlalchemy.engine.RowProxy`, or ``None``"
msgstr "`~gino.engine.GinoConnection.first` 返回`~sqlalchemy.engine.RowProxy`的第一个元素或者`None`"

#: ../../schema.rst:82
msgid ""
":meth:`~gino.engine.GinoConnection.scalar` returns a single value, or "
"``None``"
msgstr "`~gino.engine.GinoConnection.scalar`返回唯一结果值或者`None`"

#: ../../schema.rst:84
msgid ""
":meth:`~gino.engine.GinoConnection.iterate` returns an asynchronous iterator"
" which yields :class:`~sqlalchemy.engine.RowProxy`"
msgstr "`~gino.engine.GinoConnection.iterate`返回`~sqlalchemy.engine.RowProxy`的异步可迭代的对象"

#: ../../schema.rst:87
msgid "Please go to their API for more information."
msgstr "如果想获取更多信息，请前往API部分查看"

#: ../../schema.rst:91
msgid "GINO Core"
msgstr "GINO 核心"

#: ../../schema.rst:93
msgid ""
"In previous scenario, :class:`~gino.engine.GinoEngine` must not be set to "
":attr:`metadata.bind <sqlalchemy.schema.MetaData.bind>` because it is not a "
"regular SQLAlchemy Engine thus it won't work correctly. For this, GINO "
"provides a subclass of :class:`~sqlalchemy.schema.MetaData` as "
":class:`~gino.api.Gino`, usually instantiated globally under the name of "
"``db``. It can be used as a normal :class:`~sqlalchemy.schema.MetaData` "
"still offering some conveniences:"
msgstr "在之前的场景下，不能将GinoEngine设置为metadata.bind，
因为它不是常规的SQLAlchemy Engine，因此它无法正常工作。基于这个原因，
GINO实现了`~gino.api.Gino`类，它是`~sqlalchemy.schema.MetaData`的子类，
通常在全局实例化为`db`变量，同时它也可以像一般的`~sqlalchemy.schema.MetaData`进行使用，
从而使用起来更加方便．
"

#: ../../schema.rst:100
msgid "It delegates most public types you can access on ``sqlalchemy``"
msgstr "代理了sqlalchemy的大多数公共类型"

#: ../../schema.rst:101
msgid ""
"It works with both normal SQLAlchemy engine and asynchronous GINO engine"
msgstr "能够同时适用于SQLAlchemy 引擎和　GINO引擎"

#: ../../schema.rst:102
msgid ""
"It exposes all query APIs on :class:`~gino.engine.GinoConnection` level"
msgstr "基于`~gino.engine.GinoConnection` 开发了所有的查询API"

#: ../../schema.rst:103
msgid ""
"It injects two ``gino`` extensions on SQLAlchemy query clauses and schema "
"items, allowing short inline execution like ``users.select().gino.all()``"
msgstr "它在SQLAlchemy查询子句和模式项上注入了两个`gino`` 扩展，
允许像``users.select().gino.all()``这样的短内联执行."

#: ../../schema.rst:105
msgid "It is also the entry for the third scenario, see later"
msgstr "也是稍后会看到的第三种方式的前提"

#: ../../schema.rst:107
msgid "Then we can achieve previous scenario with less code like this::"
msgstr "现在我们可以使用更少的代码来实现之前的场景"

#: ../../schema.rst:139
msgid ""
"Similar to SQLAlchemy core and ORM, this is GINO core. All tables and "
"queries are still made of SQLAlchemy whose rules still apply, but "
"``sqlalchemy`` seems never imported. This is useful when ORM is unwanted."
msgstr "与SQLAlchemy核心和ORM相似的就是GINO核心，所有的表和请求都是以SQLAlchemy的方式使用的，
但是确没用引入``sqlalchemy`` 库，当不需要使用ORM时，它是很合适的．"

#: ../../schema.rst:145
msgid ""
"`asyncpgsa <https://github.com/CanopyTax/asyncpgsa/>`_ does the same thing, "
"but in a conceptually reversed way - instead of having asyncpg work for "
"SQLAlchemy, it made SQLAlchemy work for asyncpg (GINO used to be in that way"
" too because GINO is inspired by asyncpgsa). Either way works fine, it's "
"just a matter of taste of whose API style to use, SQLAlchemy or asyncpg."
msgstr ""

#: ../../schema.rst:153
msgid "GINO ORM"
msgstr "GINO ORM"

#: ../../schema.rst:155
msgid ""
"If you want to further reduce the length of code, and taking a bit risk of "
"implicity, welcome to the ORM world. Even though GINO made itself not quite "
"a traditional ORM by being simple and explict to safely work with asyncio, "
"common ORM concepts are still valid - a table is a model class, a row is a "
"model instance. Still the same example rewritten in GINO ORM::"
msgstr "如果你想要更进一步的减少代码的长度，以及冒一点隐瞒的风险，那么采用ORM是及其合适的，
尽管GINO通过简单而明确地使用asyncio来使自己不是传统的ORM，但是常见的ORM概念仍然有效 - 表是模型类，行是模型实例。
现在使用GINO ORM来重写之前的实例．
"

#: ../../schema.rst:191
msgid "The ``__tablename__`` is a mandatory field to define a concrete model."
msgstr "``__tablename__``是必填字段，用于定义具体模型。"

#: ../../schema.rst:193
msgid ""
"As you can see, the declaration is pretty much the same as before. "
"Underlying they are identical, declaring two tables in ``db``. The ``class``"
" style is just more declarative. Instead of ``users.c.name``, you can now "
"access the column by ``User.name``. The implicitly created "
":class:`~sqlalchemy.schema.Table` is available at ``User.__table__`` and "
"``Address.__table__``. You can use anything that works in GINO core here."
msgstr "如你所见，申明的方式和之前使用的是一样的，在db中声明两个表。 ``class``风格更具说明性。 
现在可以通过User.name访问该列，而不是users.c.name。 
隐式创建的`~sqlalchemy.schema.Table` 表可在``User.__table__``和``Address.__table__``_中找到。 
可以在这里使用任何适用于GINO核心的东西。"

#: ../../schema.rst:202
msgid ""
"``db.Model`` is a dynamically created parent class for your models. It is "
"associated with the ``db`` on initialization, therefore the table is put in "
"the very ``db`` when you declare your model class."
msgstr "``db.Model``是动态创建的模型的父类，使用``db``来进行初始化，所以，在声明模型类时，
都需要继承``db``"

#: ../../schema.rst:206
msgid ""
"Things become different when it comes to CRUD. You can use model level "
"methods to directly :meth:`~gino.crud.CRUDModel.create` a model instance, "
"instead of inserting a new row. Or :meth:`~gino.crud.CRUDModel.delete` a "
"model instance without needing to specify the where clause manually. Query "
"returns model instances instead of :class:`~sqlalchemy.engine.RowProxy`, and"
" row values are directly available as attributes on model instances. See "
"also: :doc:`/crud`."
msgstr "当涉及CRUD的时候，就会有些区别了，可以使用模型级别的方法，比如`~gino.crud.CRUDModel.create`
来创建模型实例，来插入一行数据，或者`~gino.crud.CRUDModel.delete`来删除模型实例，而不需要定义相关的列，
返回的时模型实例而不是`~sqlalchemy.engine.RowProxy`，行的列值可以直接通过模型实例的属性获取，其它详情
请查看`/crud`相关说明．
"

#: ../../schema.rst:213
msgid ""
"After all, :class:`~gino.engine.GinoEngine` is always in use. Next let's dig"
" more into it."
msgstr "毕竟，GinoEngine一直在使用。 接下来让我们深入研究它。"
